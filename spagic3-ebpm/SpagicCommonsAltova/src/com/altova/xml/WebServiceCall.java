/**
 * WebServiceCall.java
 *
 * This file was generated by MapForce 2007sp1.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the MapForce Documentation for further details.
 * http://www.altova.com/mapforce
 */

package com.altova.xml;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.StringWriter;
import java.net.HttpURLConnection;
import java.net.URL;

import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

public class WebServiceCall
{
	private String endpointURL;
	private String soapAction;
	private String encoding;
	private String operationName;
	private String WSDLTargetNamespace;
	private String operationLocation;
	private byte style;
	private byte httpContentType;

	private String username = "";
	private String password = "";

	public static final byte UNKNOWN = 0;

	public static final byte SOAP_RPC_ENCODED = 1;
	public static final byte SOAP_DOCUMENT_LITERAL = 2;
	public static final byte HTTP_GET = 3;
	public static final byte HTTP_POST= 4;

	public static final byte HTTP_URL_ENCODED = 1;
	public static final byte HTTP_URL_REPLACEMENT = 2;
	public static final byte HTTP_XML = 3;

	public WebServiceCall(String endpointURL, String WSDLTargetNamespace, String operationName, String soapAction, String encoding, byte style)
	{
		this.endpointURL = endpointURL;
		this.soapAction = soapAction;
		this.encoding = encoding;
		this.WSDLTargetNamespace = WSDLTargetNamespace;
		this.operationName = operationName;
		this.style = style;
	}

	public WebServiceCall(String endpointURL, String opLocation, byte contentType, String encoding, byte style)
	{
		this.endpointURL = endpointURL;
		this.operationLocation= opLocation;
		this.httpContentType = contentType;
		this.encoding = encoding;
		this.style = style;
	}

	public void setCredentials( String u, String p)
	{
		username = u;
		password = p;
	}

	public boolean call (Node in, Node out) throws Exception
	{
		org.w3c.dom.Node node = null;
		if (in != null)
			node = in.getDomNode();

		//  non soap case
		if (style == HTTP_GET || style == HTTP_POST)
		{
			HttpURLConnection conn = null;

			String urlOperation = endpointURL + operationLocation;
			String parameters = "";

			// construct parameters from  parts
			if (node != null)
			{
				org.w3c.dom.NodeList parts = node.getChildNodes();
				if (httpContentType == HTTP_XML && style == HTTP_POST)
				{
					if (parts.getLength() > 1)
						throw new Exception ("HTTP POST with text/xml encoding can handle only one part");
					if (parts.getLength() == 1)
					{
						javax.xml.transform.Transformer xformer = javax.xml.transform.TransformerFactory.newInstance().newTransformer();
						//xformer.setOutputProperty("indent", "yes");
						//xformer.setOutputProperty("omit-xml-declaration", "yes");
						javax.xml.transform.Source source = new javax.xml.transform.dom.DOMSource(parts.item(0));
						java.io.StringWriter swr = new java.io.StringWriter();
						xformer.transform(source, new  javax.xml.transform.stream.StreamResult(swr));
						parameters = swr.toString();
					}
				}
				else if (httpContentType == HTTP_URL_ENCODED )
				{
					for (int i = 0; i<parts.getLength(); i++)
					{
						if (i>0)
							parameters += "&";
						parameters += java.net.URLEncoder.encode(parts.item(i).getLocalName(), "UTF-8");
						parameters += "=";
						parameters += java.net.URLEncoder.encode(Node.getDomNodeValue(parts.item(i)), "UTF-8");
					}
				}
				else
					throw new Exception ("Unsuported mime type for HTTP binding");
			}

			if (style == HTTP_GET)
			{
				if (parameters.length() > 0)
					urlOperation += ("?" + parameters);
				URL url = new URL(urlOperation);
				conn = (HttpURLConnection) url.openConnection();
				conn.setRequestMethod("GET");

				if (username.length() > 0 && password.length() > 0)
					conn.setRequestProperty("Authentication", "Basic " + base64Encode(username + ":" + password));

				conn.connect();
			}
			else // POST
			{
				URL url = new URL(urlOperation);
				conn = (HttpURLConnection) url.openConnection();
				conn.setRequestMethod("POST");

				if (httpContentType == HTTP_XML)
					conn.setRequestProperty("Content-Type", "text/xml; charset=" + encoding);
				else if (httpContentType == HTTP_URL_ENCODED )
					conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
				else
					throw new Exception ("Unsuported mime type for HTTP binding");

				if (username.length() > 0 && password.length() > 0)
					conn.setRequestProperty("Authentication", "Basic " + base64Encode(username + ":" + password));

				conn.setDoInput(true);
				conn.setDoOutput(true);

				byte[] buff = parameters.getBytes(encoding);
				conn.setRequestProperty("Content-Length", String.valueOf(buff.length));
				OutputStream connectionStream = conn.getOutputStream();
				connectionStream.write(buff);
				connectionStream.close();
			}

			if (conn.getResponseCode() == HttpURLConnection.HTTP_OK)
			{
				org.w3c.dom.Document doc = Document.getDomBuilder().parse(conn.getInputStream());
				out.getDomNode().appendChild(out.getDomNode().getOwnerDocument().importNode(doc.getDocumentElement(),true));
				return true;
			}
			else
				throw new Exception ("Failed: " + conn.getResponseCode() + " " + conn.getResponseMessage());
		}
		else if (style == SOAP_DOCUMENT_LITERAL || style == SOAP_RPC_ENCODED)
		{
			org.w3c.dom.Document soapDoc = Document.getDomBuilder().newDocument();
			org.w3c.dom.Element envelope = soapDoc.createElementNS("http://schemas.xmlsoap.org/soap/envelope/", "SOAP-ENV:Envelope");
			envelope.setAttribute("xmlns:SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/");
			envelope.setAttribute("xmlns:SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/");
			envelope.setAttribute("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
			envelope.setAttribute("xmlns:xsd", "http://www.w3.org/2001/XMLSchema");

			org.w3c.dom.Element body = soapDoc.createElementNS("http://schemas.xmlsoap.org/soap/envelope/", "SOAP-ENV:Body");
			org.w3c.dom.Element header = soapDoc.createElementNS("http://schemas.xmlsoap.org/soap/envelope/", "SOAP-ENV:Header");

			if (style == SOAP_RPC_ENCODED)
			{
				// create rpcEnvelope
				org.w3c.dom.Element rpcEnvelope = soapDoc.createElementNS(WSDLTargetNamespace, "m:"+ operationName); // don't ask
				rpcEnvelope.setAttribute("xmlns:m", WSDLTargetNamespace);
				rpcEnvelope.setAttribute("SOAP-ENV:encodingStyle", "http://schemas.xmlsoap.org/soap/encoding/");
				
				// take all attributes from root element, insert them into rpcEnvelope (?)
				org.w3c.dom.NamedNodeMap attrs = node.getAttributes();
				for (int i = 0; i<attrs.getLength(); i++)
				{
					String attrName = ((org.w3c.dom.Attr)attrs.item(i)).getName();
					rpcEnvelope.setAttribute(attrName, ((org.w3c.dom.Attr)attrs.item(i)).getValue());
				}

				// and add children of root node to rpcEnvelope
				if (node != null)
				{
					org.w3c.dom.NodeList parts = node.getChildNodes();
					int count = parts.getLength();
					
					// headers 0..n-1
					for (int i = 0; i < count-1; i++)
						header.appendChild(soapDoc.importNode(parts.item(i), true));
					// message is last
					org.w3c.dom.Node dummyMsgRoot = parts.item(count-1);
					
					for (int i = 0; i< dummyMsgRoot.getChildNodes().getLength(); i++)
						rpcEnvelope.appendChild(soapDoc.importNode(dummyMsgRoot.getChildNodes().item(i), true));
				}
				body.appendChild(rpcEnvelope);
			}
			else
			{
				if (node != null)
				{
					org.w3c.dom.NodeList parts = node.getChildNodes();
					int count = parts.getLength();
					
					// headers 0..n-1
					for (int i = 0; i < count-1; i++)
						header.appendChild(soapDoc.importNode(parts.item(i), true));
					// message is last
					org.w3c.dom.Node dummyMsgRoot = parts.item(count-1);
			
					for (int i = 0; i< dummyMsgRoot.getChildNodes().getLength(); i++)
						body.appendChild(soapDoc.importNode(dummyMsgRoot.getChildNodes().item(i), true));
				}
			}

			if (header.getChildNodes().getLength() > 0)
				envelope.appendChild(header);
			envelope.appendChild(body);
			soapDoc.appendChild(envelope);

			// turn it into text and send it away

			Transformer xformer = TransformerFactory.newInstance().newTransformer();
			Source source = new DOMSource(soapDoc);
			StringWriter swr = new StringWriter();
			Result result = new StreamResult(swr);
			xformer.transform(source, result);
			String req = swr.toString();
			byte[] buff = req.getBytes(encoding);
			int len = buff.length;

			// calculate length set headers and send it away
			URL url = new URL(endpointURL);
			HttpURLConnection conn = (HttpURLConnection) url.openConnection();

			// TODO set this according to style (soap - non soap)
			conn.setRequestMethod("POST");
			conn.setRequestProperty("Content-Length", String.valueOf(len));
			conn.setRequestProperty("Content-Type", "text/xml; charset=" + encoding);
			conn.setRequestProperty("SOAPAction", soapAction);

			if (username.length() > 0 && password.length() > 0)
				conn.setRequestProperty("Authentication", "Basic " + base64Encode(username + ":" + password));

			conn.setDoInput(true);
			conn.setDoOutput(true);

			OutputStream connectionStream = conn.getOutputStream();
			connectionStream.write(buff);
			connectionStream.close();

			if (conn.getResponseCode() == 200)
				soapDoc = Document.getDomBuilder().parse(conn.getInputStream());
			else
				soapDoc = Document.getDomBuilder().parse(conn.getErrorStream());

			// check mustUnderstand
			org.w3c.dom.NodeList headers = soapDoc.getElementsByTagNameNS("http://schemas.xmlsoap.org/soap/envelope/", "Header");
			if (headers.getLength() > 1)
				throw new Exception("More than one header found");
			if (headers.getLength() == 1)
			{
				for (org.w3c.dom.Node headerNode = headers.item(0).getFirstChild(); headerNode != null; headerNode = headerNode.getNextSibling())
					if (headerNode.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE)
					{
						org.w3c.dom.Attr muAtt = ((org.w3c.dom.Element)headerNode).getAttributeNodeNS("http://schemas.xmlsoap.org/soap/envelope/", "mustUnderstand");
						if (muAtt != null && (muAtt.getNodeValue().equals("1") || muAtt.getNodeValue().equals("true")))
							throw new Exception("Cannot process messages with mustUnderstand headers");
					}
			}

			org.w3c.dom.NodeList bodies = soapDoc.getElementsByTagNameNS("http://schemas.xmlsoap.org/soap/envelope/", "Body");
			if (bodies.getLength() != 1)
				throw new Exception("Bad body count: need one, got " + bodies.getLength());
			body = (org.w3c.dom.Element) bodies.item(0);
			node = out.getDomNode();
			java.util.ArrayList  bodyChildren = new java.util.ArrayList();;
			for (int i=0; i< body.getChildNodes().getLength(); ++i)
				if (body.getChildNodes().item(i).getNodeType() == org.w3c.dom.Node.ELEMENT_NODE)
					bodyChildren.add(body.getChildNodes().item(i));

			org.w3c.dom.Element bodyChild = (org.w3c.dom.Element)bodyChildren.get(0);

			// now check the child of body: if it is "soap-env:Fault", it's a well, fault.
			// the only difference between docLit ant rpcEnc faults is that part has xsi:type, but we don't have to check it
			if (bodyChildren.size() == 1 &&
					bodyChild.getLocalName().equals("Fault") &&
					bodyChild.getNamespaceURI().equals("http://schemas.xmlsoap.org/soap/envelope/"))
			{
				// it's a fault; create fault node and copy details into it
				org.w3c.dom.Element faultEnvelope = node.getOwnerDocument().createElementNS("http://schemas.xmlsoap.org/soap/envelope/", "soapenv:Fault");

				org.w3c.dom.Node detailNode = body.getElementsByTagName("detail").item(0);
				if ( detailNode != null )
				{
					org.w3c.dom.NodeList detailChildren = detailNode.getChildNodes();
					for (int i = 0; i<detailChildren.getLength(); i++) // this should copy references as well
						if (detailChildren.item(i).getNodeType() == org.w3c.dom.Node.ELEMENT_NODE)
							faultEnvelope.appendChild(faultEnvelope.getOwnerDocument().importNode(detailChildren.item(i), true));
				}
				// AFTER detail, copy, other soapenv:Fault's children
				for (org.w3c.dom.Node faultInfoNode = bodyChild.getFirstChild(); faultInfoNode != null; faultInfoNode = faultInfoNode.getNextSibling())
					if (!faultInfoNode.getLocalName().equals("detail"))
						faultEnvelope.appendChild(faultEnvelope.getOwnerDocument().importNode(faultInfoNode, true));

				node.appendChild(faultEnvelope);
				return false; // fault!
			}

			if (style == SOAP_DOCUMENT_LITERAL)
			{
				// bodyChildren are parts
				for (int i = 0; i<bodyChildren.size(); i++)
					node.appendChild(node.getOwnerDocument().importNode(((org.w3c.dom.Element)bodyChildren.get(i)), true));
			}
			else if (style == SOAP_RPC_ENCODED)
			{
				if ( bodyChildren.size() == 0)
					throw new Exception("Bad rpc-env count: need one, got none");

				org.w3c.dom.Element rpcEnv = (org.w3c.dom.Element) bodyChildren.get(0);

				org.w3c.dom.NodeList parts = rpcEnv.getChildNodes();
				for (int i = 0; i<parts.getLength(); i++)
					if (parts.item(i).getNodeType() == org.w3c.dom.Node.ELEMENT_NODE)
						node.appendChild(node.getOwnerDocument().importNode(parts.item(i), true));

				// handle references
				for (org.w3c.dom.Node refNode = rpcEnv.getNextSibling(); refNode != null; refNode = refNode.getNextSibling())
					if (refNode.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE)
						node.appendChild(node.getOwnerDocument().importNode(refNode, true));
			}
			return true;
		}
		else
			throw new Exception ("Unsuported style");
	}

	private String base64Encode(String srcString)
	{
		String encodeArray = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

		byte[] src = srcString.getBytes();

		if (src.length == 0)
			return "";

		int tmpSize, i;
		int buff;

		tmpSize =src.length / 3 * 3;

		StringWriter dstWriter = new StringWriter((src.length * 4 / 3) + 8);

		for (i =0; i < tmpSize; i += 3)
		{
			buff = src[i] << 16 | src[i+1] << 8 | src[i+2];
			dstWriter.write(encodeArray.charAt((buff >> 18) & 0x3F));
			dstWriter.write(encodeArray.charAt((buff >> 12) & 0x3F));
			dstWriter.write(encodeArray.charAt((buff >> 6) & 0x3F));
			dstWriter.write(encodeArray.charAt((buff) & 0x3F));
		}

		int rest = src.length - tmpSize;
		if (rest == 2)
		{
			buff = src[i] << 8 | src[i+1];
			dstWriter.write(encodeArray.charAt((buff >> 10) & 0x3F));
			dstWriter.write(encodeArray.charAt((buff >> 4) & 0x3F));
			dstWriter.write(encodeArray.charAt((buff <<  2) & 0x3F));
			dstWriter.write("=");
		}
		else if (rest == 1)
		{
			buff = src[i];
			dstWriter.write(encodeArray.charAt((buff >> 2) & 0x3F));
			dstWriter.write(encodeArray.charAt((buff << 4) & 0x3F));
			dstWriter.write("==");
		}

		return dstWriter.toString();
	}
}
