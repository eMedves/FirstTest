////////////////////////////////////////////////////////////////////////
//
// DataElement.java
//
// This file was generated by MapForce 2007sp1.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//
////////////////////////////////////////////////////////////////////////

package com.altova.text.edi;

import com.altova.text.ITextNode;
import com.altova.text.Generator;
import java.io.IOException;

public class DataElement extends StructureItem {
	DataTypeValidator mValidator;
	boolean mExactlyOneChar;

	public DataElement (String name, DataTypeValidator validator) {
		super(name, ITextNode.DataElement);
		mValidator = validator;
		mExactlyOneChar = false;
	}

	public DataElement (String name) {
		super(name, ITextNode.DataElement);
		mValidator = null;
		mExactlyOneChar =true;
	}

	public boolean read (Parser.Context context) {

		if (isExactlyOneChar())
		{
			if (context.getScanner().isAtEnd())
				return false;

			Scanner scanner = context.getScanner();
			char c = scanner.rawConsumeChar();
			String s = new String(); s += c;
			context.getGenerator().insertElement (context.getParticle().getName(), s, mNodeClass);
			return true;
		}

		StringBuffer s = context.getScanner().consumeString(ServiceChars.ComponentSeparator, true);
		if ( s.length() == 0 )
			return false;  // data element is absent

		if (!mValidator.makeValidOnRead (s, context))
			return false;

		context.getGenerator().insertElement (context.getParticle().getName(), s.toString(), mNodeClass);

		return true;
	}

	public void write (Writer writer, ITextNode node) throws IOException {

		if (isExactlyOneChar())
		{
			writer.write(node.getValue());
			return;
		}

		StringBuffer value = new StringBuffer(node.getValue());

		if (!mValidator.makeValidOnWrite (value, writer))
			return;

		writer.write (value.toString());
	}

	boolean isExactlyOneChar() {
		return mExactlyOneChar;
	}
}