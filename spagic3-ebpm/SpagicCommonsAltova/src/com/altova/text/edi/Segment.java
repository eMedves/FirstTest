////////////////////////////////////////////////////////////////////////
//
// Segment.java
//
// This file was generated by MapForce 2007sp1.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//
////////////////////////////////////////////////////////////////////////

package com.altova.text.edi;

import java.io.IOException;
import com.altova.text.ITextNode;
import com.altova.text.Generator;

public class Segment extends StructureItem 	{
	public Segment (String name, Particle[] children) {
		super(name, ITextNode.Segment, children);
	}

	public boolean read (Parser.Context context) {

		Scanner scanner = context.getScanner();
		Scanner.State preserved = scanner.getCurrentState();

		// check if current segment starts here.
		if (!isSegmentStarting (context))
		{
			scanner.setCurrentState(preserved);
			return false;
		}

		if (mName.equals("UNA"))  // read EDIFACT service string advice
			return scanner.readUNA ();

		if (mName.equals("ISA"))  // X12 ISA segment defines the data element separator here
			if (!scanner.readISASegmentStart())
				return false;

		// skip data element separator eventually following and do sanity checks
		if (scanner.isAtSeparator (ServiceChars.DataElementSeparator))
			scanner.rawConsumeChar();
		else if (!scanner.isAtSeparator (ServiceChars.SegmentTerminator))
			return false;		// invalid input character.

		context.getGenerator().enterElement (context.getParticle().getName(), mNodeClass);	// begin node construction

		readChildren (context, ServiceChars.DataElementSeparator);

		if (mName.equals("ISA"))  // X12 ISA segment defines the segment terminator here
		{
			if (!scanner.readISASegmentEnd())
			{
				context.getGenerator().leaveElement (context.getParticle().getName());
				return false;
			}

			ITextNode fi15 = context.getGenerator().getCurrentNode().getChildren().getFirstNodeByName("FI15");
			if (fi15 != null  && fi15.getValue().length() != 0)
				context.getScanner().getServiceChars().setComponentSeparator(fi15.getValue().charAt(0));

			ITextNode fi65 = context.getGenerator().getCurrentNode().getChildren().getFirstNodeByName("FI65");
			if (fi65 != null && fi65.getValue().length() != 0)
			{
				context.getScanner().getServiceChars().setRepetitionSeparator(fi65.getValue().charAt(0));
				if (Character.isLetterOrDigit(context.getScanner().getServiceChars().getRepetitionSeparator()))
					context.getScanner().getServiceChars().setRepetitionSeparator('\0');
			}
		}

		if (!scanner.isAtSeparator(ServiceChars.SegmentTerminator))
			context.handleError(Parser.ExtraData);

		scanner.forwardToSegmentTerminator();

		scanner.rawConsumeChar();
		context.getGenerator().leaveElement (context.getParticle().getName());
		return true;
	}

	public void write (Writer writer, ITextNode node) throws IOException {
		// write out name and separator
		writer.write (mName);

		// even this could be omitted according to spec:
		writer.addSeparator (ServiceChars.DataElementSeparator);

		writeChildren (writer, node, ServiceChars.DataElementSeparator);
		// now no superfluous separators are left, therefore write the segment terminator.
		writer.clearPendingSeparators ();
		writer.addSeparator (ServiceChars.SegmentTerminator);

		if (writer.getNewlineAfterSegments())
			writer.write ("\r\n");
		else
			writer.write (""); // flushes out the segment terminator, so it won't be lost.
	}
}
